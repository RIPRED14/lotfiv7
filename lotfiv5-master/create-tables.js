// Script pour cr√©er les tables manquantes dans Supabase
import { createClient } from '@supabase/supabase-js';

// Configuration Supabase
const SUPABASE_URL = "https://bkdcbrnfzgnafjwnryme.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJrZGNicm5memduYWZqd25yeW1lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU2ODA1MTAsImV4cCI6MjA2MTI1NjUxMH0.cdzP9f_Bg1TlrBs-v1DsOb5Iv-tfK0KURPwZn1hwYMU";

// Cr√©er le client
const supabase = createClient(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Scripts SQL pour la cr√©ation des tables
const createAnalysesTables = `
-- Enable UUID generation
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Cr√©ation de la table pour les analyses planifi√©es
CREATE TABLE IF NOT EXISTS analyses_planifiees (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  bacterie TEXT NOT NULL,
  delai TEXT NOT NULL,
  jour TEXT NOT NULL,
  semaine INTEGER NOT NULL,
  date_analyse DATE NOT NULL,
  site TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Cr√©ation de la table pour les analyses en cours
CREATE TABLE IF NOT EXISTS analyses_en_cours (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  bacterie TEXT NOT NULL,
  delai TEXT NOT NULL,
  date_analyse DATE NOT NULL,
  site TEXT NOT NULL,
  status TEXT DEFAULT 'En cours',
  sample_data JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Cr√©ation d'un d√©clencheur pour mettre √† jour la date de modification
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Appliquer le d√©clencheur aux deux tables
CREATE TRIGGER set_updated_at_analyses_planifiees
BEFORE UPDATE ON analyses_planifiees
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER set_updated_at_analyses_en_cours
BEFORE UPDATE ON analyses_en_cours
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Cr√©ation d'index pour optimiser les recherches
CREATE INDEX idx_analyses_planifiees_semaine ON analyses_planifiees(semaine);
CREATE INDEX idx_analyses_planifiees_jour ON analyses_planifiees(jour);
CREATE INDEX idx_analyses_en_cours_status ON analyses_en_cours(status);
`;

const addSampleFields = `
-- Migration pour ajouter les champs li√©s aux analyses bact√©riologiques
ALTER TABLE IF EXISTS samples
ADD COLUMN IF NOT EXISTS analysis_type TEXT NULL,
ADD COLUMN IF NOT EXISTS analysis_delay TEXT NULL,
ADD COLUMN IF NOT EXISTS reading_day TEXT NULL,
ADD COLUMN IF NOT EXISTS notification_sent BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS reading_due_date TIMESTAMP WITH TIME ZONE NULL;

-- Mettre √† jour les index pour optimiser les recherches
CREATE INDEX IF NOT EXISTS idx_samples_analysis_type ON samples(analysis_type);
CREATE INDEX IF NOT EXISTS idx_samples_reading_day ON samples(reading_day);
CREATE INDEX IF NOT EXISTS idx_samples_reading_due_date ON samples(reading_due_date);

-- Fonction pour automatiser les notifications lorsque les d√©lais d'analyses sont atteints
CREATE OR REPLACE FUNCTION check_bacteria_readings()
RETURNS TRIGGER AS $$
BEGIN
  -- D√©terminer la date de lecture en fonction du type d'analyse
  IF NEW.analysis_delay = '24h' THEN
    NEW.reading_due_date := NEW.created_at + INTERVAL '24 hours';
  ELSIF NEW.analysis_delay = '48h' THEN
    NEW.reading_due_date := NEW.created_at + INTERVAL '48 hours';
  ELSIF NEW.analysis_delay = '5j' THEN
    NEW.reading_due_date := NEW.created_at + INTERVAL '5 days';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- D√©clencher la fonction lors de la cr√©ation ou mise √† jour d'un √©chantillon
DROP TRIGGER IF EXISTS set_bacteria_reading_dates ON samples;
CREATE TRIGGER set_bacteria_reading_dates
BEFORE INSERT OR UPDATE ON samples
FOR EACH ROW
WHEN (NEW.analysis_type IS NOT NULL AND NEW.analysis_delay IS NOT NULL)
EXECUTE FUNCTION check_bacteria_readings();
`;

// Donn√©es initiales pour les tests (optionnel)
const initialData = `
-- Ajouter quelques donn√©es initiales pour les tests
INSERT INTO analyses_planifiees (bacterie, delai, jour, semaine, date_analyse, site)
VALUES
  ('Ent√©robact√©ries', '24h', 'Lundi', EXTRACT(WEEK FROM CURRENT_DATE), CURRENT_DATE, 'R1'),
  ('Coliformes totaux', '5j', 'Mercredi', EXTRACT(WEEK FROM CURRENT_DATE), CURRENT_DATE + INTERVAL '2 days', 'R2'),
  ('Listeria', '48h', 'Vendredi', EXTRACT(WEEK FROM CURRENT_DATE), CURRENT_DATE + INTERVAL '4 days', 'BAIKO');

-- Ajouter quelques donn√©es initiales pour les analyses en cours
INSERT INTO analyses_en_cours (bacterie, delai, date_analyse, site, status)
VALUES
  ('Ent√©robact√©ries', '24h', CURRENT_DATE - INTERVAL '1 day', 'R1', 'En cours'),
  ('Coliformes totaux', '5j', CURRENT_DATE - INTERVAL '3 days', 'R2', 'En cours');
`;

// Fonction pour ex√©cuter les requ√™tes SQL
async function executeSql(sql, description) {
  console.log(`\nüîÑ Ex√©cution: ${description}...`);
  
  try {
    const { error } = await supabase.rpc('exec_sql', { sql_query: sql });
    
    if (error) {
      // Essayer une approche diff√©rente si la premi√®re √©choue
      try {
        console.log("Tentative avec PostgreSQL brut...");
        const { error: rawError } = await supabase.rpc('pg_execute', { command: sql });
        
        if (rawError) {
          // Troisi√®me tentative avec une approche plus basique (par morceaux)
          const statements = sql.split(';').filter(stmt => stmt.trim() !== '');
          let failedStatements = 0;
          
          for (const statement of statements) {
            if (statement.trim() === '') continue;
            
            const cleanedStatement = statement.trim() + ';';
            console.log(`Ex√©cution s√©par√©e: ${cleanedStatement.substring(0, 50)}...`);
            
            try {
              const { error: stmtError } = await supabase.rpc('exec_sql', { sql_query: cleanedStatement });
              if (stmtError) {
                console.warn(`‚ö†Ô∏è √âchec d'ex√©cution partielle:`, stmtError);
                failedStatements++;
              }
            } catch (stmtErr) {
              console.warn(`‚ö†Ô∏è Exception lors de l'ex√©cution partielle:`, stmtErr);
              failedStatements++;
            }
          }
          
          if (failedStatements > 0) {
            console.warn(`‚ö†Ô∏è ${failedStatements} instruction(s) ont √©chou√©`);
            throw new Error(`√âchec partiel: ${failedStatements} instruction(s) ont √©chou√©`);
          }
        }
      } catch (rawErr) {
        console.error(`‚ùå √âchec de l'ex√©cution de la migration: ${description}`, error);
        console.error("D√©tails:", error.message);
        throw error;
      }
    }
    
    console.log(`‚úÖ Migration ex√©cut√©e avec succ√®s: ${description}`);
    return true;
    
  } catch (err) {
    console.error(`‚ùå Exception lors de l'ex√©cution: ${description}`, err);
    return false;
  }
}

// Cr√©ation des tables et des fonctions
async function createTables() {
  let success = true;
  
  // M√©thode alternative: cr√©er les tables individuellement via l'API REST
  try {
    console.log("üîÑ Cr√©ation des tables via l'API REST...");
    
    // 1. Cr√©ation de la table analyses_planifiees
    console.log("\nüîÑ Cr√©ation de la table 'analyses_planifiees'...");
    const planifiees = await fetch(`${SUPABASE_URL}/rest/v1/analyses_planifiees?select=*`, {
      method: 'GET',
      headers: {
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
      }
    });
    
    if (planifiees.status === 404) {
      // La table n'existe pas, nous devons la cr√©er via SQL
      console.log("Table 'analyses_planifiees' non trouv√©e, cr√©ation n√©cessaire via SQL");
    } else if (planifiees.ok) {
      console.log("‚úÖ Table 'analyses_planifiees' existe d√©j√†");
    }
    
    // 2. Cr√©ation de la table analyses_en_cours
    console.log("\nüîÑ Cr√©ation de la table 'analyses_en_cours'...");
    const enCours = await fetch(`${SUPABASE_URL}/rest/v1/analyses_en_cours?select=*`, {
      method: 'GET',
      headers: {
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
      }
    });
    
    if (enCours.status === 404) {
      // La table n'existe pas, nous devons la cr√©er via SQL
      console.log("Table 'analyses_en_cours' non trouv√©e, cr√©ation n√©cessaire via SQL");
    } else if (enCours.ok) {
      console.log("‚úÖ Table 'analyses_en_cours' existe d√©j√†");
    }
    
    // 3. Tester si nous avons acc√®s au SQL via des RPC personnalis√©es
    console.log("\nüîÑ Test des fonctions SQL...");
    const { data: rpcData, error: rpcError } = await supabase.rpc('version');
    if (rpcError) {
      console.warn("‚ö†Ô∏è Les fonctions RPC ne sont pas disponibles:", rpcError);
      console.log("Cr√©ation de SQL via l'interface Supabase requise.");
      
      // Afficher les instructions pour cr√©er manuellement
      console.log("\nüìã INSTRUCTIONS POUR CR√âATION MANUELLE:");
      console.log("1. Connectez-vous √† votre projet Supabase: https://app.supabase.com");
      console.log("2. Allez √† la section 'Table Editor'");
      console.log("3. Cr√©ez deux nouvelles tables avec les structures suivantes:");
      console.log("\n--- STRUCTURE DE LA TABLE 'analyses_planifiees' ---");
      console.log(`
CREATE TABLE analyses_planifiees (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  bacterie TEXT NOT NULL,
  delai TEXT NOT NULL,
  jour TEXT NOT NULL,
  semaine INTEGER NOT NULL,
  date_analyse DATE NOT NULL,
  site TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);`);
      
      console.log("\n--- STRUCTURE DE LA TABLE 'analyses_en_cours' ---");
      console.log(`
CREATE TABLE analyses_en_cours (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  bacterie TEXT NOT NULL,
  delai TEXT NOT NULL,
  date_analyse DATE NOT NULL,
  site TEXT NOT NULL,
  status TEXT DEFAULT 'En cours',
  sample_data JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);`);
      
      return false;
    }
    
    console.log("‚úÖ Acc√®s SQL disponible, version PostgreSQL:", rpcData);
    
  } catch (restErr) {
    console.error("‚ùå Erreur lors de l'acc√®s √† l'API REST:", restErr);
  }
  
  console.log("\nüöÄ Ex√©cution des migrations SQL...");
  
  // 1. Cr√©er les tables d'analyses
  success = await executeSql(createAnalysesTables, "Cr√©ation des tables d'analyses") && success;
  
  // 2. Ajouter les champs √† la table samples
  success = await executeSql(addSampleFields, "Ajout des champs d'analyse aux √©chantillons") && success;
  
  // 3. Ajouter des donn√©es initiales (optionnel)
  const addInitialData = false; // Modifier √† true pour ajouter des donn√©es de test
  if (addInitialData) {
    success = await executeSql(initialData, "Ajout de donn√©es initiales") && success;
  }
  
  return success;
}

// V√©rifier les tables apr√®s cr√©ation
async function verifyTables() {
  console.log("\nüîç V√©rification des tables apr√®s cr√©ation...");
  
  // V√©rifier les tables
  const tables = ['analyses_planifiees', 'analyses_en_cours'];
  
  for (const table of tables) {
    console.log(`\nüîç V√©rification de la table '${table}'...`);
    
    try {
      const { data, error } = await supabase
        .from(table)
        .select('count');
        
      if (error) {
        console.error(`‚ùå La table '${table}' n'a pas √©t√© cr√©√©e correctement:`, error);
      } else {
        console.log(`‚úÖ Table '${table}' cr√©√©e avec succ√®s.`);
        console.log(`   Nombre d'enregistrements:`, data[0]?.count || 0);
      }
    } catch (err) {
      console.error(`‚ùå Erreur lors de la v√©rification de '${table}':`, err);
    }
  }
}

// Ex√©cution du script
async function main() {
  console.log("üöÄ D√©but de la cr√©ation des tables Supabase...");
  
  try {
    const success = await createTables();
    
    if (success) {
      console.log("\n‚úÖ Tables cr√©√©es avec succ√®s!");
      await verifyTables();
    } else {
      console.log("\n‚ö†Ô∏è Cr√©ation des tables partiellement r√©ussie ou √©chou√©e.");
      console.log("Veuillez consulter les instructions ci-dessus pour la cr√©ation manuelle.");
    }
  } catch (err) {
    console.error("\n‚ùå Erreur lors de la cr√©ation des tables:", err);
  }
}

main().catch(err => {
  console.error("‚ùå Erreur fatale:", err);
}); 